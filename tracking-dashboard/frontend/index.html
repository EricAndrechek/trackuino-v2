<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Balloon Tracking Map</title>
    <link rel="manifest" href="/manifest.json">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">
    <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#00274c">
    <meta name="msapplication-TileColor" content="#2b5797">
    <meta name="theme-color" content="#ffffff">

    <script src="/main.js"></script>

    <script src='https://api.mapbox.com/mapbox-gl-js/v3.2.0/mapbox-gl.js'></script>
    <link href='https://api.mapbox.com/mapbox-gl-js/v3.2.0/mapbox-gl.css' rel='stylesheet' />
    <script src='https://unpkg.com/@turf/turf@6/turf.min.js'></script>

    <link rel="stylesheet" href="/styles.css">

    <script src="https://unpkg.com/mqtt@5.5.1/dist/mqtt.min.js"></script>
</head>
<body>
    <div id="map"></div>
    <div style="display: none" id="layer-selector1" class="mapboxgl-ctrl mapboxgl-ctrl-group">
        <select id="style-selector1">
            <option value="mapbox://styles/ericandr/cluvydoes006n01pk7a9z9hwv">Streets</option>
            <option value="mapbox://styles/ericandr/cluvy4r03005g01nrdfgg89ea">Satellite Streets</option>
        </select>
    </div>
    <div id="notification"></div>
    <script>        
        onload = () => {
            mapboxgl.accessToken =
                "pk.eyJ1IjoiZXJpY2FuZHIiLCJhIjoiY2x1cnp3Z2tpMDcybTJycGVwN2czNTk3OCJ9.Ccv9oGIfUewgj2Iw-CqOyw";

            var map = new mapboxgl.Map({
                accessToken: mapboxgl.accessToken,
                container: "map",
                attributionControl: false,
                style: "mapbox://styles/ericandr/cluvydoes006n01pk7a9z9hwv",
                center: [-83.710993, 42.294517],
                zoom: 9,
            });

            let styleChange = false;

            const loopHandler = () => {
                // loop to update map with new data
                if (styleChange) {
                    styleChange = false;
                    return;
                }

                // get tracks and update map with all tracks and their linestrings
                for (const name in positions) {
                    if (name === "undefined") {
                        continue;
                    }
                    const position = positions[name];
                    if (!position || !position.name || position.name === "undefined" || position.name == undefined) {
                        console.log('Invalid position', position)
                        continue;
                    }
                    // check if source already exists
                    if (map.getSource(name)) {
                        // check when the source was last updated
                        const last_update = new Date(position.last_update);
                        const now = new Date();
                        const diff = now - last_update;
                        // if the source was last updated more than 180 minutes ago, remove it
                        if (diff > 180 * 60 * 1000 || (position.current.latitude === 0 && position.current.longitude === 0)) {
                            console.log('Removing source', name)
                            map.removeLayer(name);
                            map.removeSource(name);
                            map.removeLayer(name + "-line-coordinates");
                            map.removeLayer(name + "-line");
                            map.removeSource(name + "-line");

                            // also remove the position from the positions object
                            delete positions[name];
                            // and from telemetry object if it exists
                            if (telemetry[name]) {
                                delete telemetry[name];
                            }
                            continue;
                        }

                        // update source with new data
                        map.getSource(name).setData({
                            type: "Feature",
                            properties: {
                                name: position.name,
                                symbol: position.symbol,
                                altitude: position.current.altitude,
                                speed: position.current.speed,
                                heading: position.current.course,
                                last_update: position.current.datetime,
                            },
                            geometry: {
                                type: "Point",
                                coordinates: [position.current.longitude, position.current.latitude, position.current.altitude]
                            },
                        });
                        map.getSource(name + "-line").setData(getHistoricalGeoJSON(name));
                    } else {
                        // create a new GeoJSON source and add it to the map
                        const geojson = {
                            type: "Feature",
                            properties: {
                                name: position.name,
                                symbol: position.symbol,
                                altitude: position.current.altitude,
                                speed: position.current.speed,
                                heading: position.current.course,
                                last_update: position.current.datetime,
                            },
                            geometry: {
                                type: "Point",
                                coordinates: [position.current.longitude,position.current.latitude, position.current.altitude]
                            },
                        };
                        console.log('Adding new source', name, geojson, getHistoricalGeoJSON(name));

                        map.addSource(name, {
                            type: "geojson",
                            data: geojson,
                        });
                        map.addLayer({
                            id: name,
                            source: name,
                            type: 'symbol',
                            layout: {
                                'icon-image': ['get', 'symbol'],
                                'icon-allow-overlap': true,
                                'icon-size': 0.1,
                                'icon-rotate': ['get', 'heading'],
                                'icon-rotation-alignment': 'map',
                                'symbol-placement': 'point',
                                'symbol-z-elevate': true
                            },
                            paint: {
                                'icon-color': nameToColor(name),
                            }
                        });

                        map.addSource(name + "-line", {
                            type: "geojson",
                            data: getHistoricalGeoJSON(name),
                        });

                        // draw line, and add point for each coordinate
                        map.addLayer({
                            id: name + "-line",
                            type: "line",
                            source: name + "-line",
                            layout: {
                                "line-join": "round",
                                "line-cap": "round",
                            },
                            paint: {
                                "line-color": nameToColor(name),
                                "line-width": 2,
                            },
                        });
                        // and coordinates
                        map.addLayer({
                            id: name + "-line-coordinates",
                            type: "circle",
                            source: name + "-line",
                            paint: {
                                "circle-radius": 5,
                                "circle-color": nameToColor(name),
                            },
                        });
                    }
                }
                setTimeout(loopHandler, 100);
            }

            const getCustomImages = async () => {
                // load svgs
                const response = await fetch("/svgs.json");
                const svgs = await response.json();
                console.log('Loaded svgs', svgs);
                for (const svg of svgs) {
                    console.log('Loading image', svg);
                    map.loadImage(svg.url, (error, image) => {
                        if (error) {
                            console.error('Error loading image: ', svg, ' with error: ', error);
                            return;
                        }
                        map.addImage(svg.name, image, { sdf: true });
                    });
                    // load flipped image if it exists
                    if (!svg.url2) {
                        // make image with flip url the same as the original
                        svg.url2 = svg.url;
                    }
                    map.loadImage(svg.url2, (error, image) => {
                        if (error) {
                            console.error('Error loading image', error);
                            return;
                        }
                        map.addImage(svg.name + "-flip", image, { sdf: true });
                    });
                }
            }

            map.on('style.load', () => {
                console.log('Style loaded');
                getCustomImages();

                // delay 1 seconds to allow map to load for sure before adding data
                setTimeout(() => {
                    console.log('Map loaded');
                    // get class mapboxgl-ctrl-attrib-inner
                    let attrib = document.getElementsByClassName(
                        "mapboxgl-ctrl-attrib-inner"
                    )[0];
                    // edit innerHTML of attrib
                    attrib.innerHTML =
                        "UMich Balloon Map | Made by <a href='https://github.com/EricAndrechek'>Eric</a>";

                    console.log('Adding data');
                    loopHandler();
                }, 1000);
            });


            const geolocate = new mapboxgl.GeolocateControl({
                positionOptions: {
                    enableHighAccuracy: true,
                },
                // When active the map will receive updates to the device's location as it changes.
                trackUserLocation: true,
                // Draw an arrow next to the location dot to indicate which direction the device is heading.
                showUserHeading: true,
            })

            map.addControl(geolocate);
            map.addControl(new mapboxgl.NavigationControl());
            map.addControl(new mapboxgl.AttributionControl(
                {
                    compact: true,
                    customAttribution: "UMich Balloon Tracking Map | <a href='https://github.com/EricAndrechek' target='_blank'>Made by Eric</a>"
                }
            ));
            map.addControl(new mapboxgl.ScaleControl());

            map.on("load", async () => {
                // start geolocate right away
                geolocate.trigger();

                // wait 1 second to allow map to load before adding data
                setTimeout(() => {
                    // get class mapboxgl-ctrl-top-left
                    let top_left = document.getElementsByClassName(
                        "mapboxgl-ctrl-top-left"
                    )[0];
                    // copy clone of layer-selector1 to top_left
                    let layer_selector1 = document.getElementById("layer-selector1").cloneNode(true);
                    // change id of layer_selector1 to layer-selector
                    layer_selector1.id = "layer-selector";
                    // change style-selector1 to style-selector
                    layer_selector1.children[0].id = "style-selector";
                    // add layer_selector1 to top_left
                    top_left.appendChild(layer_selector1);
                    // show layer-selector1
                    layer_selector1.style.display = "block";

                    // When a new style is selected, update the map style
                    document
                        .getElementById("style-selector")
                        .addEventListener("change", function (e) {
                            styleChange = true;
                            map.setStyle(e.target.value);
                        });

                    // get class mapboxgl-ctrl-top-right
                    let top_right = document.getElementsByClassName(
                        "mapboxgl-ctrl-top-right"
                    )[0];
                    // create new div
                    let new_div = document.createElement("div");
                    // set class of new div
                    new_div.className = "mapboxgl-ctrl mapboxgl-ctrl-group";
                    // add div to new_div
                    new_div.innerHTML = `
                        <button class="mapboxgl-ctrl-icon" aria-label="Settings"  style="padding: 2px;" onclick="settings()">
                            <img src="/assets/settings.svg" alt="Settings">
                        </button>
                    `;
                    // add new_div to top_right
                    top_right.appendChild(new_div);
                }, 1000);
            });

            geolocate.on('error', () => {
                console.log('GeoLocation error');
            });

            map.on('error', (e) => {
                console.log('Map error', e);
            });

            const call_symbol_popup = (feature) => {
                const coordinates = feature.geometry.coordinates.slice();
                const name = feature.properties.name;
                const altitude = feature.properties.altitude;
                const speed = feature.properties.speed;
                const heading = feature.properties.heading;
                const last_update = feature.properties.last_update;

                const popup = new mapboxgl.Popup()
                    .setLngLat(coordinates)
                    .setHTML(
                        `<h3>${name}</h3>
                        <p>Altitude: ${altitude} m</p>
                        <p>Speed: ${speed} m/s</p>
                        <p>Heading: ${heading}°</p>
                        <p>Last Update: ${last_update}</p>`
                    )
                    .addTo(map);
            }

            const call_circle_popup = (feature, closest) => {
                // first 2 elements of closest are lng, lat
                const coordinates = closest.slice(0, 2);
                const name = feature.properties.name;

                let popup_data = `<h3>${name}</h3>`;
                // add coordinates to 6 decimal places
                popup_data += `<p>Coordinates: ${coordinates[1].toFixed(6)}, ${coordinates[0].toFixed(6)}</p>`;

                // this data should be in the geojson object
                if (closest.length !== 7) {
                    console.error('Point missing data: ', closest);
                } else {
                    const altitude = closest[2];
                    const speed = closest[3];
                    const heading = closest[4];
                    const comment = closest[5];
                    const last_update = closest[6];

                    // set popup with data (only data that is not undefined, none, null, "", etc)
                    
                    if (altitude) {
                        popup_data += `<p>Altitude: ${altitude} m</p>`;
                    }
                    if (speed) {
                        popup_data += `<p>Speed: ${speed} m/s</p>`;
                    }
                    if (heading) {
                        popup_data += `<p>Heading: ${heading}°</p>`;
                    }
                    if (comment) {
                        popup_data += `<p>Comment: ${comment}</p>`;
                    }
                    if (last_update) {
                        popup_data += `<p>Data Timestamp: ${last_update}</p>`;
                    }
                }

                const popup = new mapboxgl.Popup()
                    .setLngLat(coordinates)
                    .setHTML(popup_data)
                    .addTo(map);
            }

            map.on('click', (e) => {
                // should be able to click on a symbol (car or balloon) and pop-open a popup with more information
                // or click on a circle on the line and pop-open a popup with more information

                // get features at the point that were created by us
                let features = [];
                try {
                    features = map.queryRenderedFeatures(e.point);
                } catch (error) {
                    // ignore RangeError
                    if (error instanceof RangeError) {
                        return;
                    }
                    console.error('Error querying rendered features', error);
                }

                if (features.length === 0) {
                    return;
                }

                // get first "symbol" in layer.type
                let feature = features.find((feature) => feature.layer.type === "symbol");
                // if no symbol, get first "circle" in layer.type
                if (!feature) {
                    feature = features.find((feature) => feature.layer.type === "circle");
                }
                if (!feature) {
                    return;
                }

                // if its a symbol, call popup with more information
                if (feature.layer.type === "symbol") {
                    call_symbol_popup(feature);
                } else if (feature.layer.type === "circle") {
                    // use turf nearestPointOnLine to get closest point on line to clicked coords
                    const line = map.getSource(feature.source)._data;
                    // convert line to turf line
                    const turf_line = turf.lineString(line.geometry.coordinates);
                    // convert clicked coords to turf point
                    const turf_point = turf.point(e.lngLat.toArray());
                    // get closest point on line to clicked coords
                    const closest = turf.nearestPointOnLine(turf_line, turf_point);
                    call_circle_popup(feature, closest.geometry.coordinates);
                }
            });
        };
    </script>
    <script src="/mqtt.js"></script>
    <script>
        // Progressive Web App service worker registration
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('/service-worker.js')
            .then(() => console.log('Service Worker registered successfully.'))
            .catch(error => console.error('Service Worker registration failed:', error));
        }
    </script>
</body>
</html>
